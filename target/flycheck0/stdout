{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/context.rs","byte_start":2953,"byte_end":2957,"line_start":73,"line_end":73,"column_start":29,"column_end":33,"is_primary":true,"text":[{"text":"                for t in &e.tags {","highlight_start":29,"highlight_end":33}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/context.rs","byte_start":2957,"byte_end":2957,"line_start":73,"line_end":73,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"                for t in &e.tags {","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/context.rs:73:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for t in &e.tags {\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                for t in &e.tags\u001b[92m()\u001b[0m {\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/context.rs","byte_start":2953,"byte_end":2957,"line_start":73,"line_end":73,"column_start":29,"column_end":33,"is_primary":true,"text":[{"text":"                for t in &e.tags {","highlight_start":29,"highlight_end":33}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/context.rs","byte_start":2957,"byte_end":2957,"line_start":73,"line_end":73,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"                for t in &e.tags {","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/context.rs:73:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for t in &e.tags {\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                for t in &e.tags\u001b[92m()\u001b[0m {\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/context.rs","byte_start":3017,"byte_end":3018,"line_start":74,"line_end":74,"column_start":58,"column_end":59,"is_primary":true,"text":[{"text":"                    if t != \"raw-data\" { *tag_freq.entry(t.as_str()).or_default() += 1; }","highlight_start":58,"highlight_end":59}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/context.rs:74:58\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if t != \"raw-data\" { *tag_freq.entry(t.as_str()).or_default() += 1; }\n   \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/context.rs","byte_start":3017,"byte_end":3018,"line_start":74,"line_end":74,"column_start":58,"column_end":59,"is_primary":true,"text":[{"text":"                    if t != \"raw-data\" { *tag_freq.entry(t.as_str()).or_default() += 1; }","highlight_start":58,"highlight_end":59}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/context.rs:74:58\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if t != \"raw-data\" { *tag_freq.entry(t.as_str()).or_default() += 1; }\n   \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/export.rs","byte_start":938,"byte_end":942,"line_start":21,"line_end":21,"column_start":47,"column_end":51,"is_primary":true,"text":[{"text":"                let tags_list: Vec<Value> = e.tags.iter()","highlight_start":47,"highlight_end":51}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/export.rs","byte_start":942,"byte_end":942,"line_start":21,"line_end":21,"column_start":51,"column_end":51,"is_primary":true,"text":[{"text":"                let tags_list: Vec<Value> = e.tags.iter()","highlight_start":51,"highlight_end":51}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/export.rs:21:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let tags_list: Vec<Value> = e.tags.iter()\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                let tags_list: Vec<Value> = e.tags\u001b[92m()\u001b[0m.iter()\n   \u001b[1m\u001b[94m|\u001b[0m                                                   \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/export.rs","byte_start":938,"byte_end":942,"line_start":21,"line_end":21,"column_start":47,"column_end":51,"is_primary":true,"text":[{"text":"                let tags_list: Vec<Value> = e.tags.iter()","highlight_start":47,"highlight_end":51}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/export.rs","byte_start":942,"byte_end":942,"line_start":21,"line_end":21,"column_start":51,"column_end":51,"is_primary":true,"text":[{"text":"                let tags_list: Vec<Value> = e.tags.iter()","highlight_start":51,"highlight_end":51}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/export.rs:21:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let tags_list: Vec<Value> = e.tags.iter()\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                let tags_list: Vec<Value> = e.tags\u001b[92m()\u001b[0m.iter()\n   \u001b[1m\u001b[94m|\u001b[0m                                                   \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/export.rs","byte_start":990,"byte_end":991,"line_start":22,"line_end":22,"column_start":41,"column_end":42,"is_primary":false,"text":[{"text":"                    .map(|t| Value::Str(t.clone())).collect();","highlight_start":41,"highlight_end":42}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/export.rs","byte_start":976,"byte_end":977,"line_start":22,"line_end":22,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"                    .map(|t| Value::Str(t.clone())).collect();","highlight_start":27,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/export.rs","byte_start":977,"byte_end":977,"line_start":22,"line_end":22,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"                    .map(|t| Value::Str(t.clone())).collect();","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/export.rs:22:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .map(|t| Value::Str(t.clone())).collect();\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^\u001b[0m             \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    .map(|t\u001b[92m: /* Type */\u001b[0m| Value::Str(t.clone())).collect();\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[92m++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/export.rs","byte_start":990,"byte_end":991,"line_start":22,"line_end":22,"column_start":41,"column_end":42,"is_primary":false,"text":[{"text":"                    .map(|t| Value::Str(t.clone())).collect();","highlight_start":41,"highlight_end":42}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/export.rs","byte_start":976,"byte_end":977,"line_start":22,"line_end":22,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"                    .map(|t| Value::Str(t.clone())).collect();","highlight_start":27,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/export.rs","byte_start":977,"byte_end":977,"line_start":22,"line_end":22,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"                    .map(|t| Value::Str(t.clone())).collect();","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/export.rs:22:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .map(|t| Value::Str(t.clone())).collect();\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^\u001b[0m             \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    .map(|t\u001b[92m: /* Type */\u001b[0m| Value::Str(t.clone())).collect();\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[92m++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `links` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":2437,"byte_end":2442,"line_start":53,"line_end":53,"column_start":36,"column_end":41,"is_primary":true,"text":[{"text":"                for (lt, li) in &e.links {","highlight_start":36,"highlight_end":41}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":2442,"byte_end":2442,"line_start":53,"line_end":53,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"                for (lt, li) in &e.links {","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `links` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:53:36\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for (lt, li) in &e.links {\n   \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                for (lt, li) in &e.links\u001b[92m()\u001b[0m {\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `links` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":2437,"byte_end":2442,"line_start":53,"line_end":53,"column_start":36,"column_end":41,"is_primary":true,"text":[{"text":"                for (lt, li) in &e.links {","highlight_start":36,"highlight_end":41}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":2442,"byte_end":2442,"line_start":53,"line_end":53,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"                for (lt, li) in &e.links {","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `links` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:53:36\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for (lt, li) in &e.links {\n   \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                for (lt, li) in &e.links\u001b[92m()\u001b[0m {\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `source` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":2921,"byte_end":2927,"line_start":64,"line_end":64,"column_start":56,"column_end":62,"is_primary":true,"text":[{"text":"            let is_source_match = is_source_query && e.source.as_ref()","highlight_start":56,"highlight_end":62}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":2927,"byte_end":2927,"line_start":64,"line_end":64,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"            let is_source_match = is_source_query && e.source.as_ref()","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `source` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:64:56\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let is_source_match = is_source_query && e.source.as_ref()\n   \u001b[1m\u001b[94m|\u001b[0m                                                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            let is_source_match = is_source_query && e.source\u001b[92m()\u001b[0m.as_ref()\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `source` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":2921,"byte_end":2927,"line_start":64,"line_end":64,"column_start":56,"column_end":62,"is_primary":true,"text":[{"text":"            let is_source_match = is_source_query && e.source.as_ref()","highlight_start":56,"highlight_end":62}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":2927,"byte_end":2927,"line_start":64,"line_end":64,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"            let is_source_match = is_source_query && e.source.as_ref()","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `source` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:64:56\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let is_source_match = is_source_query && e.source.as_ref()\n   \u001b[1m\u001b[94m|\u001b[0m                                                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            let is_source_match = is_source_query && e.source\u001b[92m()\u001b[0m.as_ref()\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `confidence` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":3857,"byte_end":3867,"line_start":84,"line_end":84,"column_start":28,"column_end":38,"is_primary":true,"text":[{"text":"            relevance *= e.confidence;","highlight_start":28,"highlight_end":38}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":3867,"byte_end":3867,"line_start":84,"line_end":84,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"            relevance *= e.confidence;","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `confidence` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:84:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             relevance *= e.confidence;\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            relevance *= e.confidence\u001b[92m()\u001b[0m;\n   \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `confidence` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":3857,"byte_end":3867,"line_start":84,"line_end":84,"column_start":28,"column_end":38,"is_primary":true,"text":[{"text":"            relevance *= e.confidence;","highlight_start":28,"highlight_end":38}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":3867,"byte_end":3867,"line_start":84,"line_end":84,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"            relevance *= e.confidence;","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `confidence` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:84:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             relevance *= e.confidence;\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            relevance *= e.confidence\u001b[92m()\u001b[0m;\n   \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":4521,"byte_end":4525,"line_start":98,"line_end":98,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"                tags: e.tags.clone(), relevance,","highlight_start":25,"highlight_end":29}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":4525,"byte_end":4525,"line_start":98,"line_end":98,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                tags: e.tags.clone(), relevance,","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:98:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 tags: e.tags.clone(), relevance,\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                tags: e.tags\u001b[92m()\u001b[0m.clone(), relevance,\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":4521,"byte_end":4525,"line_start":98,"line_end":98,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"                tags: e.tags.clone(), relevance,","highlight_start":25,"highlight_end":29}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":4525,"byte_end":4525,"line_start":98,"line_end":98,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"                tags: e.tags.clone(), relevance,","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:98:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 tags: e.tags.clone(), relevance,\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                tags: e.tags\u001b[92m()\u001b[0m.clone(), relevance,\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `confidence` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":4576,"byte_end":4586,"line_start":99,"line_end":99,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":"                confidence: e.confidence, link_in,","highlight_start":31,"highlight_end":41}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":4586,"byte_end":4586,"line_start":99,"line_end":99,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"                confidence: e.confidence, link_in,","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `confidence` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:99:31\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 confidence: e.confidence, link_in,\n   \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                confidence: e.confidence\u001b[92m()\u001b[0m, link_in,\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `confidence` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":4576,"byte_end":4586,"line_start":99,"line_end":99,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":"                confidence: e.confidence, link_in,","highlight_start":31,"highlight_end":41}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":4586,"byte_end":4586,"line_start":99,"line_end":99,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"                confidence: e.confidence, link_in,","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `confidence` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:99:31\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 confidence: e.confidence, link_in,\n   \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                confidence: e.confidence\u001b[92m()\u001b[0m, link_in,\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `links` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":4806,"byte_end":4811,"line_start":106,"line_end":106,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"                .any(|e| !e.links.is_empty() && matched_offsets.contains(&e.offset));","highlight_start":29,"highlight_end":34}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":4811,"byte_end":4811,"line_start":106,"line_end":106,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"                .any(|e| !e.links.is_empty() && matched_offsets.contains(&e.offset));","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `links` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:106:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 .any(|e| !e.links.is_empty() && matched_offsets.contains(&e.offset));\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                .any(|e| !e.links\u001b[92m()\u001b[0m.is_empty() && matched_offsets.contains(&e.offset));\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `links` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":4806,"byte_end":4811,"line_start":106,"line_end":106,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"                .any(|e| !e.links.is_empty() && matched_offsets.contains(&e.offset));","highlight_start":29,"highlight_end":34}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":4811,"byte_end":4811,"line_start":106,"line_end":106,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"                .any(|e| !e.links.is_empty() && matched_offsets.contains(&e.offset));","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `links` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:106:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 .any(|e| !e.links.is_empty() && matched_offsets.contains(&e.offset));\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                .any(|e| !e.links\u001b[92m()\u001b[0m.is_empty() && matched_offsets.contains(&e.offset));\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `links` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":5471,"byte_end":5476,"line_start":116,"line_end":116,"column_start":66,"column_end":71,"is_primary":true,"text":[{"text":"                    if !matched_offsets.contains(&e.offset) || e.links.is_empty() { continue; }","highlight_start":66,"highlight_end":71}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":5476,"byte_end":5476,"line_start":116,"line_end":116,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"                    if !matched_offsets.contains(&e.offset) || e.links.is_empty() { continue; }","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `links` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:116:66\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if !matched_offsets.contains(&e.offset) || e.links.is_empty() { continue; }\n    \u001b[1m\u001b[94m|\u001b[0m                                                                  \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    if !matched_offsets.contains(&e.offset) || e.links\u001b[92m()\u001b[0m.is_empty() { continue; }\n    \u001b[1m\u001b[94m|\u001b[0m                                                                       \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `links` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":5555,"byte_end":5560,"line_start":117,"line_end":117,"column_start":54,"column_end":59,"is_primary":true,"text":[{"text":"                    for (link_topic, link_idx) in &e.links {","highlight_start":54,"highlight_end":59}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":5560,"byte_end":5560,"line_start":117,"line_end":117,"column_start":59,"column_end":59,"is_primary":true,"text":[{"text":"                    for (link_topic, link_idx) in &e.links {","highlight_start":59,"highlight_end":59}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `links` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:117:54\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m117\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for (link_topic, link_idx) in &e.links {\n    \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m117\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    for (link_topic, link_idx) in &e.links\u001b[92m()\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":5627,"byte_end":5637,"line_start":118,"line_end":118,"column_start":65,"column_end":75,"is_primary":true,"text":[{"text":"                        if let Some(&pos) = topic_idx_map.get(&(link_topic.as_str(), *link_idx)) {","highlight_start":65,"highlight_end":75}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:118:65\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         if let Some(&pos) = topic_idx_map.get(&(link_topic.as_str(), *link_idx)) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `links` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":5471,"byte_end":5476,"line_start":116,"line_end":116,"column_start":66,"column_end":71,"is_primary":true,"text":[{"text":"                    if !matched_offsets.contains(&e.offset) || e.links.is_empty() { continue; }","highlight_start":66,"highlight_end":71}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":5476,"byte_end":5476,"line_start":116,"line_end":116,"column_start":71,"column_end":71,"is_primary":true,"text":[{"text":"                    if !matched_offsets.contains(&e.offset) || e.links.is_empty() { continue; }","highlight_start":71,"highlight_end":71}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `links` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:116:66\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if !matched_offsets.contains(&e.offset) || e.links.is_empty() { continue; }\n    \u001b[1m\u001b[94m|\u001b[0m                                                                  \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    if !matched_offsets.contains(&e.offset) || e.links\u001b[92m()\u001b[0m.is_empty() { continue; }\n    \u001b[1m\u001b[94m|\u001b[0m                                                                       \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `links` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":5555,"byte_end":5560,"line_start":117,"line_end":117,"column_start":54,"column_end":59,"is_primary":true,"text":[{"text":"                    for (link_topic, link_idx) in &e.links {","highlight_start":54,"highlight_end":59}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":5560,"byte_end":5560,"line_start":117,"line_end":117,"column_start":59,"column_end":59,"is_primary":true,"text":[{"text":"                    for (link_topic, link_idx) in &e.links {","highlight_start":59,"highlight_end":59}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `links` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:117:54\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m117\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for (link_topic, link_idx) in &e.links {\n    \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m117\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    for (link_topic, link_idx) in &e.links\u001b[92m()\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":5627,"byte_end":5637,"line_start":118,"line_end":118,"column_start":65,"column_end":75,"is_primary":true,"text":[{"text":"                        if let Some(&pos) = topic_idx_map.get(&(link_topic.as_str(), *link_idx)) {","highlight_start":65,"highlight_end":75}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:118:65\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         if let Some(&pos) = topic_idx_map.get(&(link_topic.as_str(), *link_idx)) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":6470,"byte_end":6474,"line_start":129,"line_end":129,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"                                    tags: le.tags.clone(),","highlight_start":46,"highlight_end":50}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":6474,"byte_end":6474,"line_start":129,"line_end":129,"column_start":50,"column_end":50,"is_primary":true,"text":[{"text":"                                    tags: le.tags.clone(),","highlight_start":50,"highlight_end":50}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:129:46\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   tags: le.tags.clone(),\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                                    tags: le.tags\u001b[92m()\u001b[0m.clone(),\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `confidence` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":6540,"byte_end":6550,"line_start":130,"line_end":130,"column_start":57,"column_end":67,"is_primary":true,"text":[{"text":"                                    relevance: 3.0 * le.confidence,","highlight_start":57,"highlight_end":67}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":6550,"byte_end":6550,"line_start":130,"line_end":130,"column_start":67,"column_end":67,"is_primary":true,"text":[{"text":"                                    relevance: 3.0 * le.confidence,","highlight_start":67,"highlight_end":67}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `confidence` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:130:57\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   relevance: 3.0 * le.confidence,\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                                    relevance: 3.0 * le.confidence\u001b[92m()\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m                                                                   \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":6470,"byte_end":6474,"line_start":129,"line_end":129,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"                                    tags: le.tags.clone(),","highlight_start":46,"highlight_end":50}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":6474,"byte_end":6474,"line_start":129,"line_end":129,"column_start":50,"column_end":50,"is_primary":true,"text":[{"text":"                                    tags: le.tags.clone(),","highlight_start":50,"highlight_end":50}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:129:46\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   tags: le.tags.clone(),\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                                    tags: le.tags\u001b[92m()\u001b[0m.clone(),\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `confidence` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":6603,"byte_end":6613,"line_start":131,"line_end":131,"column_start":52,"column_end":62,"is_primary":true,"text":[{"text":"                                    confidence: le.confidence, link_in: le_link_in,","highlight_start":52,"highlight_end":62}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":6613,"byte_end":6613,"line_start":131,"line_end":131,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"                                    confidence: le.confidence, link_in: le_link_in,","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `confidence` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:131:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   confidence: le.confidence, link_in: le_link_in,\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                                    confidence: le.confidence\u001b[92m()\u001b[0m, link_in: le_link_in,\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `confidence` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":6540,"byte_end":6550,"line_start":130,"line_end":130,"column_start":57,"column_end":67,"is_primary":true,"text":[{"text":"                                    relevance: 3.0 * le.confidence,","highlight_start":57,"highlight_end":67}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":6550,"byte_end":6550,"line_start":130,"line_end":130,"column_start":67,"column_end":67,"is_primary":true,"text":[{"text":"                                    relevance: 3.0 * le.confidence,","highlight_start":67,"highlight_end":67}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `confidence` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:130:57\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   relevance: 3.0 * le.confidence,\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                                    relevance: 3.0 * le.confidence\u001b[92m()\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m                                                                   \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `confidence` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/reconstruct.rs","byte_start":6603,"byte_end":6613,"line_start":131,"line_end":131,"column_start":52,"column_end":62,"is_primary":true,"text":[{"text":"                                    confidence: le.confidence, link_in: le_link_in,","highlight_start":52,"highlight_end":62}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/reconstruct.rs","byte_start":6613,"byte_end":6613,"line_start":131,"line_end":131,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"                                    confidence: le.confidence, link_in: le_link_in,","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `confidence` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/reconstruct.rs:131:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   confidence: le.confidence, link_in: le_link_in,\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                                    confidence: le.confidence\u001b[92m()\u001b[0m, link_in: le_link_in,\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":2815,"byte_end":2819,"line_start":71,"line_end":71,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            if !e.tags.is_empty() {","highlight_start":19,"highlight_end":23}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/score.rs","byte_start":2819,"byte_end":2819,"line_start":71,"line_end":71,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"            if !e.tags.is_empty() {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:71:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if !e.tags.is_empty() {\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            if !e.tags\u001b[92m()\u001b[0m.is_empty() {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":2815,"byte_end":2819,"line_start":71,"line_end":71,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            if !e.tags.is_empty() {","highlight_start":19,"highlight_end":23}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/score.rs","byte_start":2819,"byte_end":2819,"line_start":71,"line_end":71,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"            if !e.tags.is_empty() {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:71:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if !e.tags.is_empty() {\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            if !e.tags\u001b[92m()\u001b[0m.is_empty() {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":2911,"byte_end":2915,"line_start":73,"line_end":73,"column_start":35,"column_end":39,"is_primary":true,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":35,"highlight_end":39}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/score.rs","byte_start":2915,"byte_end":2915,"line_start":73,"line_end":73,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:73:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    .filter(|t| e.tags\u001b[92m()\u001b[0m.iter().any(|tag| tag.contains(t.as_str())))\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":2911,"byte_end":2915,"line_start":73,"line_end":73,"column_start":35,"column_end":39,"is_primary":true,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":35,"highlight_end":39}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/score.rs","byte_start":2915,"byte_end":2915,"line_start":73,"line_end":73,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:73:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    .filter(|t| e.tags\u001b[92m()\u001b[0m.iter().any(|tag| tag.contains(t.as_str())))\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":2933,"byte_end":2936,"line_start":73,"line_end":73,"column_start":57,"column_end":60,"is_primary":false,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":57,"highlight_end":60}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/score.rs","byte_start":2928,"byte_end":2931,"line_start":73,"line_end":73,"column_start":52,"column_end":55,"is_primary":true,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":52,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/score.rs","byte_start":2931,"byte_end":2931,"line_start":73,"line_end":73,"column_start":55,"column_end":55,"is_primary":true,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":55,"highlight_end":55}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:73:52\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))\n   \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    .filter(|t| e.tags.iter().any(|tag\u001b[92m: /* Type */\u001b[0m| tag.contains(t.as_str())))\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[92m++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":2933,"byte_end":2936,"line_start":73,"line_end":73,"column_start":57,"column_end":60,"is_primary":false,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":57,"highlight_end":60}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/score.rs","byte_start":2928,"byte_end":2931,"line_start":73,"line_end":73,"column_start":52,"column_end":55,"is_primary":true,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":52,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/score.rs","byte_start":2931,"byte_end":2931,"line_start":73,"line_end":73,"column_start":55,"column_end":55,"is_primary":true,"text":[{"text":"                    .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))","highlight_start":55,"highlight_end":55}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:73:52\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .filter(|t| e.tags.iter().any(|tag| tag.contains(t.as_str())))\n   \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    .filter(|t| e.tags.iter().any(|tag\u001b[92m: /* Type */\u001b[0m| tag.contains(t.as_str())))\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[92m++++++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":14562,"byte_end":14566,"line_start":334,"line_end":334,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags {","highlight_start":25,"highlight_end":29}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/score.rs","byte_start":14566,"byte_end":14566,"line_start":334,"line_end":334,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags {","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:334:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m334\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for t in &e.tags {\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m334\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            for t in &e.tags\u001b[92m()\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":14562,"byte_end":14566,"line_start":334,"line_end":334,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags {","highlight_start":25,"highlight_end":29}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/score.rs","byte_start":14566,"byte_end":14566,"line_start":334,"line_end":334,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags {","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:334:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m334\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for t in &e.tags {\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m334\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            for t in &e.tags\u001b[92m()\u001b[0m {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":14597,"byte_end":14598,"line_start":335,"line_end":335,"column_start":29,"column_end":30,"is_primary":true,"text":[{"text":"                *tags.entry(t.clone()).or_insert(0) += 1;","highlight_start":29,"highlight_end":30}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:335:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m335\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 *tags.entry(t.clone()).or_insert(0) += 1;\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/score.rs","byte_start":14597,"byte_end":14598,"line_start":335,"line_end":335,"column_start":29,"column_end":30,"is_primary":true,"text":[{"text":"                *tags.entry(t.clone()).or_insert(0) += 1;","highlight_start":29,"highlight_end":30}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/score.rs:335:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m335\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 *tags.entry(t.clone()).or_insert(0) += 1;\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":293,"byte_end":297,"line_start":9,"line_end":9,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags {","highlight_start":25,"highlight_end":29}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/stats.rs","byte_start":297,"byte_end":297,"line_start":9,"line_end":9,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags {","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:9:25\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for t in &e.tags {\n  \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            for t in &e.tags\u001b[92m()\u001b[0m {\n  \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":293,"byte_end":297,"line_start":9,"line_end":9,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags {","highlight_start":25,"highlight_end":29}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/stats.rs","byte_start":297,"byte_end":297,"line_start":9,"line_end":9,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags {","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:9:25\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for t in &e.tags {\n  \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            for t in &e.tags\u001b[92m()\u001b[0m {\n  \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":328,"byte_end":329,"line_start":10,"line_end":10,"column_start":29,"column_end":30,"is_primary":true,"text":[{"text":"                *tags.entry(t.clone()).or_insert(0) += 1;","highlight_start":29,"highlight_end":30}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:10:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 *tags.entry(t.clone()).or_insert(0) += 1;\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":328,"byte_end":329,"line_start":10,"line_end":10,"column_start":29,"column_end":30,"is_primary":true,"text":[{"text":"                *tags.entry(t.clone()).or_insert(0) += 1;","highlight_start":29,"highlight_end":30}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:10:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 *tags.entry(t.clone()).or_insert(0) += 1;\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":3342,"byte_end":3346,"line_start":85,"line_end":85,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            if !e.tags.is_empty() {","highlight_start":19,"highlight_end":23}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/stats.rs","byte_start":3346,"byte_end":3346,"line_start":85,"line_end":85,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"            if !e.tags.is_empty() {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:85:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if !e.tags.is_empty() {\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            if !e.tags\u001b[92m()\u001b[0m.is_empty() {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":3417,"byte_end":3421,"line_start":87,"line_end":87,"column_start":29,"column_end":33,"is_primary":true,"text":[{"text":"                for t in &e.tags { tags.insert(t.clone()); }","highlight_start":29,"highlight_end":33}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/stats.rs","byte_start":3421,"byte_end":3421,"line_start":87,"line_end":87,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"                for t in &e.tags { tags.insert(t.clone()); }","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:87:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for t in &e.tags { tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                for t in &e.tags\u001b[92m()\u001b[0m { tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":3342,"byte_end":3346,"line_start":85,"line_end":85,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            if !e.tags.is_empty() {","highlight_start":19,"highlight_end":23}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/stats.rs","byte_start":3346,"byte_end":3346,"line_start":85,"line_end":85,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"            if !e.tags.is_empty() {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:85:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if !e.tags.is_empty() {\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            if !e.tags\u001b[92m()\u001b[0m.is_empty() {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":3417,"byte_end":3421,"line_start":87,"line_end":87,"column_start":29,"column_end":33,"is_primary":true,"text":[{"text":"                for t in &e.tags { tags.insert(t.clone()); }","highlight_start":29,"highlight_end":33}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/stats.rs","byte_start":3421,"byte_end":3421,"line_start":87,"line_end":87,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"                for t in &e.tags { tags.insert(t.clone()); }","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:87:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for t in &e.tags { tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                for t in &e.tags\u001b[92m()\u001b[0m { tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":3436,"byte_end":3437,"line_start":87,"line_end":87,"column_start":48,"column_end":49,"is_primary":true,"text":[{"text":"                for t in &e.tags { tags.insert(t.clone()); }","highlight_start":48,"highlight_end":49}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:87:48\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for t in &e.tags { tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/stats.rs","byte_start":3436,"byte_end":3437,"line_start":87,"line_end":87,"column_start":48,"column_end":49,"is_primary":true,"text":[{"text":"                for t in &e.tags { tags.insert(t.clone()); }","highlight_start":48,"highlight_end":49}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/stats.rs:87:48\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for t in &e.tags { tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/topics.rs","byte_start":1379,"byte_end":1383,"line_start":37,"line_end":37,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags { info.tags.insert(t.clone()); }","highlight_start":25,"highlight_end":29}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/topics.rs","byte_start":1383,"byte_end":1383,"line_start":37,"line_end":37,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags { info.tags.insert(t.clone()); }","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/topics.rs:37:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for t in &e.tags { info.tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            for t in &e.tags\u001b[92m()\u001b[0m { info.tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/topics.rs","byte_start":1403,"byte_end":1404,"line_start":37,"line_end":37,"column_start":49,"column_end":50,"is_primary":true,"text":[{"text":"            for t in &e.tags { info.tags.insert(t.clone()); }","highlight_start":49,"highlight_end":50}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/topics.rs:37:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for t in &e.tags { info.tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"attempted to take value of method `tags` on type `&CachedEntry`","code":{"code":"E0615","explanation":"Attempted to access a method like a field.\n\nErroneous code example:\n\n```compile_fail,E0615\nstruct Foo {\n    x: u32,\n}\n\nimpl Foo {\n    fn method(&self) {}\n}\n\nlet f = Foo { x: 0 };\nf.method; // error: attempted to take value of method `method` on type `Foo`\n```\n\nIf you want to use a method, add `()` after it:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nf.method();\n```\n\nHowever, if you wanted to access a field of a struct check that the field name\nis spelled correctly. Example:\n\n```\n# struct Foo { x: u32 }\n# impl Foo { fn method(&self) {} }\n# let f = Foo { x: 0 };\nprintln!(\"{}\", f.x);\n```\n"},"level":"error","spans":[{"file_name":"src/topics.rs","byte_start":1379,"byte_end":1383,"line_start":37,"line_end":37,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags { info.tags.insert(t.clone()); }","highlight_start":25,"highlight_end":29}],"label":"method, not a field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use parentheses to call the method","code":null,"level":"help","spans":[{"file_name":"src/topics.rs","byte_start":1383,"byte_end":1383,"line_start":37,"line_end":37,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"            for t in &e.tags { info.tags.insert(t.clone()); }","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0615]\u001b[0m\u001b[1m: attempted to take value of method `tags` on type `&CachedEntry`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/topics.rs:37:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for t in &e.tags { info.tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mmethod, not a field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use parentheses to call the method\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            for t in &e.tags\u001b[92m()\u001b[0m { info.tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[92m++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/topics.rs","byte_start":1403,"byte_end":1404,"line_start":37,"line_end":37,"column_start":49,"column_end":50,"is_primary":true,"text":[{"text":"            for t in &e.tags { info.tags.insert(t.clone()); }","highlight_start":49,"highlight_end":50}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/topics.rs:37:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for t in &e.tags { info.tags.insert(t.clone()); }\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0282, E0615.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0282, E0615.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0282, E0615.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0282, E0615.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///Users/tal/wudan/dojo/crash3/amaranthine#6.6.0","manifest_path":"/Users/tal/wudan/dojo/crash3/amaranthine/Cargo.toml","target":{"kind":["lib","cdylib","staticlib"],"crate_types":["lib","cdylib","staticlib"],"name":"amaranthine","src_path":"/Users/tal/wudan/dojo/crash3/amaranthine/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}}
{"reason":"build-finished","success":false}
